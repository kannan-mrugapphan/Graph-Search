// 924.
//eg

// 1-2*-3*-4 consider the graph with 3 components and nodes with * are infected     
// 5-6*-7 saving 2 or 3 wont save any nodes but saving 6 saves 3 nodes and saving 9 saves 2 nodes
// 8-9* expected result - 6

//approach - group nodes in one component together using color coding
//colors = [0,0,0,0,1,1,1,2,2] - nodes 1 to 4 are 0 color, nodes 5-7 are 1 color and remaining nodes are 2 color
//find the size of each group from colors[]
//groupSize = [4,3,2] - 4 nodes with 0 color, 3 nodes with 1 color and 2 nodes with 2 color
//find the number of infected nodes in each group from colors[] and given initial[]
//infectedCount = [2,1,1] -  infected nodes in 0th group and 1 infected nodes in other 2 groups
//iterate through each node in initial[] find its respective color, group size and number of infected nodes in that group, if number of infected nodes in that group is 1 (the current node) make it healthy and update result with group size
//find that node which yeilds max result
//if 2 nodes give same result pick node with small id
//if no nodes can be made healthy return infected node with smallest id

// time - O(n^2 + size of initial[])
// space - O(n + 2c) 
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        //edge
        if(graph == null || graph.length == 0 || graph[0].length == 0)
        {
            return 0;
        }
        int[] colors = new int[graph.length]; //serves as visited[] as well
        Arrays.fill(colors, -1); //initially all nodes are unprocessed
        int color = 0; //start from color 0
        for(int i = 0; i < graph.length; i++)
        {
            //if the current node is not processed
            if(colors[i] == -1)
            {
                dfs(i, colors, graph, color); //process this group and increment color (to be used for next group)
                color++;
            }
        }
        int[] groupSize = new int[color]; //size of each component
        for(int i = 0; i < colors.length; i++)
        {
            //if ith node has color 0 increase count of 0th index in groupSize[]
            groupSize[colors[i]]++;
        }
        int[] infectedCount = new int[color]; //number of infected nodes in each group
        for(int i = 0; i < initial.length; i++)
        {
            int currentNode = initial[i];
            int currentColor = colors[currentNode];
            infectedCount[currentColor]++; //the group associated with the current node has 1 infected node so far
        }
        
        int result = Integer.MIN_VALUE; //max nodes that could be saved by making 1 infected node healthy
        Integer savedNode = null; //node to be made healthy
        for(int infected : initial)
        {
            int currentColor = colors[infected]; //get the color of current infected node
            int numberOfInfectedNodes = infectedCount[currentColor]; //# of nodes infected in this group
            int numberOfNodes = groupSize[currentColor]; //total nodes in this group
            if(numberOfInfectedNodes == 1)
            {
                //if only one node is infected in this group
                //first valid node so far
                if(savedNode == null)
                {
                    savedNode = infected;
                    result = numberOfNodes;
                }
                else
                {
                    //the current node saves more nodes than prev ans - so updating
                    if(result < numberOfNodes)
                    {
                        result = numberOfNodes;
                        savedNode = infected;
                    }
                    //the current node saves equal total - so result is min id amon prev result and current
                    if(result == numberOfNodes)
                    {
                        savedNode = Math.min(savedNode, infected);
                    }
                }
            }
        }
        //after processing all infected nodes if result is still not found find the infected node with least id
        if(savedNode == null)
        {
            savedNode = initial[0];
            for(int i = 1; i < initial.length; i++)
            {
                savedNode = Math.min(savedNode, initial[i]);
            }
        }
        return savedNode;
    }
    
    //time - O(n^2) - adj matrix representation of graph
    //space - O(n) - single component with all n nodes gives max call stack size
    private void dfs(int node, int[] colors, int[][] graph, int color) {
        //base
        if(colors[node] != -1)
        {
            //incoming node already processed
            return;
        }
        //logic
        colors[node] = color; //assign color to this node i.e mark as visited
        //for each neighbor of node
        for(int i = 0; i < graph[node].length; i++)
        {
            if(graph[node][i] == 1) //edge exists
            {
                dfs(i, colors, graph, color);
            }
        }
        return;
    }
}
